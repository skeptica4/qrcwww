-- Configuration
local multiplier = true
local BURST_DAMAGE = 10
local MAX_HITS = 100
local HIT_COOLDOWN = 0.05

-- Set up global access
_G.multiplier = multiplier

-- Target queue system
local targetQueue = {}
local activeTarget = nil
local isProcessing = false

pcall(function()
	-- Get game metatable
	local mt = getrawmetatable(game)
	setreadonly(mt, false)
	
	local originalNamecall = mt.__namecall
	
	-- Override namecall method
	mt.__namecall = newcclosure(function(self, ...)
		local method = getnamecallmethod()
		local args = {...}
		
		if _G.multiplier and 
		   method == "FireServer" and 
		   tostring(self) == "VerifyHit" then
			
			local target = args[1]
			if not target or not target:IsA("Humanoid") then
				return originalNamecall(self, ...)
			end
			
			-- Add to queue if not already processing
			if not activeTarget then
				activeTarget = target
				isProcessing = true
				
				-- Start burst processing
				task.spawn(function()
					processBurstTarget(self, args, target)
				end)
			end
		end
		
		return originalNamecall(self, ...)
	end)
	
	setreadonly(mt, true)
	
	-- Main burst processing function
	function processBurstTarget(remoteObj, baseArgs, humanoid)
		local targetParent = humanoid.Parent
		local npcName = targetParent.Name
		local startingHealth = humanoid.Health
		local currentHealth = startingHealth
		local hitCount = 1
		
		print("Starting burst multiplier on " .. npcName .. " (Health: " .. startingHealth .. ")")
		
		while currentHealth > 0 and hitCount <= MAX_HITS do
			hitCount = hitCount + 1
			
			pcall(function()
				local originalPos = baseArgs[3]
				
				if typeof(originalPos) == "Vector3" then
					local varRange = 0.01
					local halfVar = varRange / 2
					local randomX = math.random() * varRange - halfVar
					local randomY = math.random() * varRange - halfVar
					local randomZ = math.random() * varRange - halfVar
					
					local newPos = Vector3.new(
						originalPos.X + randomX,
						originalPos.Y + randomY,
						originalPos.Z + randomZ
					)
					
					local newArgs = {baseArgs[1], baseArgs[2], newPos}
					for j = 4, #baseArgs do
						newArgs[j] = baseArgs[j]
					end
					
					remoteObj:FireServer(unpack(newArgs))
				else
					remoteObj:FireServer(unpack(baseArgs))
				end
			end)
			
			currentHealth = currentHealth - BURST_DAMAGE
			task.wait(HIT_COOLDOWN)
		end
		
		print(npcName .. " defeated after " .. hitCount .. " burst hits!")
		
		-- Clear and process next target if queued
		activeTarget = nil
		isProcessing = false
	end
	
	print("Burst-until-dead damage multiplier " .. (multiplier and "enabled" or "disabled"))
end)
